import torch as th
import torch_geometric as pyg

import numpy as np
import scipy
import scipy.optimize

from .graph_metrics import *
from .utils import infer_gamma
from .distances import *

import abc
from .embedding import Embedding
from .manifolds import poincare

class LaBNE(Embedding):
    def __init__(self) -> None:
        super().__init__()
        self.manifold = poincare.PoincareManifold()
        self.name = 'LaBNE'
        self.graph = None

    def __call__(self, edge_index='edge_index', normalize_radius=False, dim=2, save_to_graph=False, save_coordinates=False, return_coordinates=False):
        """ Given a graph, returns the LaBNE embedding as described in [1].

            [1] Alanis-Lobato, G., Mier, P. & Andrade-Navarro, M. Efficient embedding of complex networks to hyperbolic space via their Laplacian. Sci Rep 6, 30108 (2016). https://doi.org/10.1038/srep30108

        Args:
            data (pyg.data.Data): The graph to embed.
            only_coordinates (Bool): Whether to return only the coordinates generated by LaBNE, or a new graph object containing these coordinates. Defaults to False.
            normalize_radius (float,Bool): Whether to normalize the radius of the embedding. Defaults to False. If a float is given, the radius will be normalized to this value.
            dim (int): The number of dimensions to embed the graph into. Defaults to 2 (i.e., (x,y), (r,Î¸)).

        Returns:
            if only_coordinates:
                (th.Tensor, th.Tensor, th.Tensor, th.Tensor): The torch Tensor's which represente x,y,r,theta coordinates for each node.
            else:
                pyg.data.Data: A copy of the inputted data object, but with coordinates set to LaBNE.
        """

        assert self.graph is not None, "No graph assigned to embedding. Please assign a graph to the embedding using the assign_graph() method."

        N = self.graph.num_nodes

        #get Laplacian matrix of the graph (L = D - A). We pass it to a sparse matrix type supported by SciPy
        #so that we can use scipy's sparse linear algebra tools
        L = pyg.utils.get_laplacian(getattr(self.graph, edge_index))
        L = pyg.utils.to_scipy_sparse_matrix(L[0], L[1])
        #the tol parameter of scipy.sparse.lingalg() is to give an error tolerance. for smaller networks, convergence seems to be
        #guaranteed with high precision. for larger networks, convergence maybe a problem, so an error tolerance is given. criteria
        #the same as in Alanis-Lobato's NetHypGeom library
        if N < 10000:
            try:
                eigenvalues, eigenvectors = scipy.sparse.linalg.eigs(A=L, k=dim+1, which='LM', sigma=0, return_eigenvectors=True)
            except(RuntimeError):
                Levenberg_c = scipy.sparse.coo_matrix((N,N), dtype=np.float64)
                Levenberg_c.setdiag(0.01)
                eigenvalues, eigenvectors = scipy.sparse.linalg.eigs(A=L+Levenberg_c, k=dim+1, which='LM', sigma=0, return_eigenvectors=True)
        else:        
            try:
                eigenvalues, eigenvectors = scipy.sparse.linalg.eigs(A=L, k=dim+1, which='LM', sigma=0, return_eigenvectors=True, tol=1E-8, maxiter=50000)
            except(RuntimeError):
                Levenberg_c = scipy.sparse.coo_matrix((N,N), dtype=np.float64)
                Levenberg_c.setdiag(0.01)
                eigenvalues, eigenvectors = scipy.sparse.linalg.eigs(A=L+Levenberg_c, k=dim+1, which='LM', sigma=0, return_eigenvectors=True, tol=1E-8, maxiter=50000)

        # x_LE_cartesian now contains the Laplacian Eigenmaps embedding to dimension dim
        x_LE_cartesian = th.Tensor(eigenvectors[:,1:])

        x_polar = to_spherical(x_LE_cartesian)
        r, gamma = radial_ordering(self.graph, edge_index=edge_index)
        # normalize r to normalize_radius
        if type(normalize_radius) == float:
            r = r * normalize_radius / r.max()
        x_polar[:,0] = r

        x_LaBNE_cartesian = to_cartesian(x_polar)

        if save_coordinates:
            # add entries LE, LaBNE_polar, LaBNE_cartesian to the embedding's coordinates dictionary
            self.save_coordinates(x_LE_cartesian, 'LE')
            self.save_coordinates(x_polar, 'LaBNE_polar')
            self.save_coordinates(x_LaBNE_cartesian, 'LaBNE_cartesian')

        if save_to_graph:
            # add entries LE, LaBNE_polar, LaBNE_cartesian to the graph's embeddings dictionary
            self.save_coordinates_to_graph(x_LE_cartesian, 'LE')
            self.save_coordinates_to_graph(x_polar, 'LaBNE_polar')
            self.save_coordinates_to_graph(x_LaBNE_cartesian, 'LaBNE_cartesian')

        if return_coordinates:
            return x_LE_cartesian, x_polar, x_LaBNE_cartesian

def radial_ordering(data:pyg.data.Data, edge_index='edge_index'):
    """ Given a graph, returns the radial ordering of the nodes as described in [1]. This is the r coordinate in the LaBNE embedding. """

    N = data.num_nodes
    r = th.zeros(N)
    degrees = pyg.utils.degree(getattr(data, edge_index)[0], N)
    # sort degrees for radial positioning
    degrees = degrees.sort(descending=True)
    gamma = infer_gamma(data).power_law.alpha
    beta = 1/(gamma-1)
    for t in range(N):
        r_t = np.log(t+1)
        r[degrees.indices[t]] = 2*beta*r_t + 2*(1-beta)*np.log(N)
    return r, gamma